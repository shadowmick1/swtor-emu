/*
* Copyright (C) 2008-2012 Emulator Nexus <http://emulatornexus.com//>
*
* This program is free software; you can redistribute it and/or modify it
* under the terms of the GNU General Public License as published by the
* Free Software Foundation; either version 3 of the License, or (at your
* option) any later version.
*
* This program is distributed in the hope that it will be useful, but WITHOUT
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
* more details.
*
* You should have received a copy of the GNU General Public License along
* with this program. If not, see <http://www.gnu.org/licenses/>.
*/

#include "tor-rsa.h"

#include "cryptopp/include/rsa.h"
#include "cryptopp/include/osrng.h"
#include "cryptopp/include/hex.h"
#include "cryptopp/include/des.h"
#include <vector>

static CryptoPP::StringSource* _privateKeyStr = 0;

void TOR_RSA_Init()
{
	std::string k = "308204BC020100300D06092A864886F70D0101010500048204A6308204A20201000282010100B23B14D060C30DDB90532994FD63F3570D025541CD086A6FFF0D44E519A804E63C31281C717440AD7BAB8FE33E06F7BD10F53D8E0FA900B8B6A08FE4CBE4133D84BCE919916ECE588450DC7915D316EE6B36ECDF811E8F039B20B18E564E5166EDC7FC7E03C4CCD2CD311CAC1C173EB3F65FB8AA055AAEB5B1503EE890691FBA840EDB6258644A4B64E7B65A2DA36C8E6C2602F608F67A0320C06863B119EF189A60B3DD8921F69A011E3D518F030E5DD89622067C472166F129BC283E8DBEEE4B6B7D57E135186A87B51FCC17AEC74673796EF8A6D9E59852E9E61D8A6D0EEEBC6B93F5F87F7D3069B621503DA1277299C8220051B595B941207EFA93553A3102011102820100092C73E5140A0A2001C80B8D50CE8E683EC9882726C9D84D4B3ECCF53424E22270464B79EF4056270C032EEF76041F9324A335FDE673FE279FFCF858F3E7F975FD6B9B0E7E12E1357F47ED3AF02EA12E2766977C71F0A1B6C61A2741ADDA9E8AF1E2C3958B7CF3F443082CC51808B9D0CACC74CC840A5085964D8AC470D83BFC564CE652FF7C442CAFCD01A2C1FB9B3AAF03E024B7EBE255C0A7D69AA4B32C568E5B197F4F2E77D1262F028756DCF329138D8CFAF054267C890BB3BC4ACEF7330256EB889094446153E075076A70F51A6969719AAA15BD4938A1E50A706A1B9CCE04397C68CFF817EEA39C404AE15AEE71645E6423CEAC70FC39199C28BC3FA902818100F085371BC064A902DC48216EFC040F80C43C7D5D587B9835BF3C3FC5A91138C59075B77F2A30539DAB653E21450406AFCB572E34B65BE3CBAF58659B7C86FC178750825D5144A10403936181FF2391A1640663D05D451E9D0E4C2BA114E1E20962D72D27732EC3F0869EE6C7637070A94160CD03F5A195F4B64610AA48076BF902818100BDB3971EA1FF0708E7EC076C78D02774F1E75E3D044AD902303503BCF5DD58E5F3010CFE136AD4416FDE84EAD6F125B4915C40C6641A9B03245BB28BA6E4001C4D823F78BB8B46DF01F44A4C4DAF7711A1BB908FF35C20481CE6A1B1A459146C9266E55D6C639C0134635ECC4FF1D01E743706875B400E0CD43BEA7658721DF902818100A9C77231B4FBC2989B7E35B7C0F3CEB53F39C1E789C0A7AD77EE4B221CFD1903ED80454AB45E59240083B362C74E22D6716AB734447D19447BC5ED5EB2412A6AF61AB65FFD2162996BEF901F86EBEE53CE22A0CF50E57F0573810FBCFFAE81700988D494514E2FF513BB75B9EBD6E61D1F17274E16CC69D9EA13570EC96EA6910281802CA2BA25534B10B6CD287A37A3F4BDFD66185268B5B7421EA1EE5B3B852505DBC0B4F3FF8C1922E2387097BEC929AE84D6E887B635ABE83CF97EFCD590AE1E24C6F17858A4993DDA1E93D53F2156765E80685E3FFD069E2F15DBE9CF71F6D7A113638143288FE878C108528A6D29D69DC0FDE36B24878AD5D795A094510BCAD102818100D544DEAB3A9F9D5C7EB46F7C62A15A87B63027E7EE58861D461C8C0D028F1C334C18B7C1E00AD4618A0C00CECC750191CE56B3D4DA3350B17D1B353EC29E6380FDE84965EFD401DAD08F0227C524A2CD0DD5D8C5E0D0FD3F6ACB86355D56C590A9F64DD5ED938685D9292FC83C99D7D8E0EF5889984265A6349D9E0CA578E780";
	_privateKeyStr = new CryptoPP::StringSource(k, true, new CryptoPP::HexDecoder);
}

unsigned char* TOR_RSA_Decrypt(unsigned char* buffer, unsigned int buffer_len, unsigned int* decrypted_len)
{
	CryptoPP::RSAES_PKCS1v15_Decryptor decryptor(*_privateKeyStr);
	CryptoPP::AutoSeededX917RNG<CryptoPP::DES_EDE3> _rng;
	std::vector<std::string> deciphered;
	for(unsigned int i = 0; i < buffer_len; i+= 256)
	{
		std::string tmp;
		CryptoPP::StringSource(std::string((char*)buffer + i, 256), true, new CryptoPP::PK_DecryptorFilter(_rng, decryptor, new CryptoPP::StringSink(tmp)));
		deciphered.push_back(tmp);
	}
	int finalSize = 0;
	for(unsigned int i=0; i < deciphered.size(); i++)
	{
		finalSize += deciphered.at(i).size();
	}
	unsigned char* result = (unsigned char*)malloc(finalSize);
	int offset = 0;
	for(unsigned int i=0; i < deciphered.size(); i++)
	{
		std::string s = deciphered.at(i);
		memcpy(result + offset, (unsigned char*)s.c_str(), s.size());
		offset += s.size();
	}
	(*(decrypted_len)) = finalSize;
	return result;
}